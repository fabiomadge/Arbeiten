Considering the various applications and good performance, it comes to no surprise that finger trees have been treated with interest by both the PL community and academia as a whole. There are numerous implementations~\cite{Haskell} available in different~\cite{Scala} languages~\cite{OCaml} and also version formalized in Isabelle~\cite{Finger-Trees-AFP}. The fact that the actual application was very concise, is very attractive, as the hard work is done in the reusable part. This can result in a better use of resources and a smaller potential for introducing bugs. Because it is a functional data structure, the bounds just being true after amortization, is not problematic, as implementations of functional programming languages generally don't target a real-time audience, that requires predictable execution times for every input.