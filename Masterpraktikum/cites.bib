@article{Huet1997,
title={The Zipper},
volume={7},
number={5},
journal={Journal of Functional Programming},
publisher={Cambridge University Press},
author={Huet, Gérard},
year={1997},
pages={549–554}
}
@article{Madge2017,
abstract = {We give a primer on \textit{Isabelle's} most heavily used mechanism to create new theorems in kernel, rule composition. Building on that understanding we discuss options for a alternative implementation. This happens with the explicit goal of shrinking the trusted code base by expressing it as a derived rule. To achieve this, existing kernel primitives are used and the results of previously trusted code are verified. We share the knowledge generated by implementing a first prototype, along with some benchmarks.
},
author = {Madge, Fabio},
title = {{Higher-Order Unification and Resolution}},
year = {2017}
}
@inproceedings{Nipkow1993,
  author    = {Tobias Nipkow},
  title     = {Functional Unification of Higher-Order Patterns},
  booktitle = {Proceedings of the Eighth Annual Symposium on Logic in Computer Science},
  pages     = {64--74},
  publisher = {{IEEE} Computer Society},
  year      = {1993}
}
@InProceedings{Huet1975,
author="Huet, Gérard",
title="Unification in typed lambda calculus",
booktitle="$\lambda$-Calculus and Computer Science Theory",
year="1975",
publisher="Springer Berlin Heidelberg",
pages="192--212",
abstract="This paper discusses the problem of finding common instances to terms in typed $\lambda$-calculus. It is shown that here the notion of most general unifier must be extended. Complete sets of unifiers are defined, and their structure with respect to substitution composition is studied."
}
@article{Miller1991,
    author = {Miller, Dale},
    title = "{A Logic Programming Language with Lambda-Abstraction, Function Variables, and Simple Unification}",
    journal = {Journal of Logic and Computation},
    volume = {1},
    number = {4},
    pages = {497-536},
    year = {1991},
    month = {09},
    abstract = "{It has been argued elsewhere that a logic programming language with function variables and λ-abstractions within terms makes a good meta-programming language, especially when an object-language contains notions of bound variables and scope. The λProlog logic programming language and the related Elf and Isabelle systems provide meta-programs with both function variables and λ-abstractions by containing implementations of higher order unification. This paper presents a logic programming language, called Lλ, that also contains both function variables and λ-abstractions, although certain restrictions are placed on occurrences of function variables. As a result of these restrictions, an implementation of Lλdoes not need to implement full higher-order unification. Instead, an extension to first-order unification that respects bound variable names and scopes is all that is required. Such unification problems are shown to be decidable and to possess most general unifiers when unifiers exist. A unification algorithm and logic programming interpreter are described and proved correct. Several examples of using Lλ as a meta-programming language are presented.}"
}


